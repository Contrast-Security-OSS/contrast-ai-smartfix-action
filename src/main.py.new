#-
# #%L
# Contrast AI SmartFix
# %%
# Copyright (C) 2025 Contrast Security, Inc.
# %%
# Contact: support@contrastsecurity.com
# License: Commercial
# NOTICE: This Software and the patented inventions embodied within may only be
# used as part of Contrast Security's commercial offerings. Even though it is
# made available through public repositories, use of this Software is subject to
# the applicable End User Licensing Agreement found at
# https://www.contrastsecurity.com/enduser-terms-0317a or as otherwise agreed
# between Contrast Security and the End User. The Software may not be reverse
# engineered, modified, repackaged, sold, redistributed or otherwise used in a
# way not consistent with the End User License Agreement.
# #L%
#

import sys
import os
import warnings
import platform
import asyncio
from datetime import datetime
from asyncio.proactor_events import _ProactorBasePipeTransport

# Add the project root to the Python path to allow for absolute imports
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
if project_root not in sys.path:
    sys.path.insert(0, project_root)

# Import core modules
from src.utils import debug_log, log, error_exit
from src.version_check import do_version_check

# Import new object-oriented modules
from src.config.smart_fix_config import SmartFixConfig
from src.telemetry.telemetry_handler import TelemetryHandler
from src.api.contrast_api_client import ContrastApiClient
from src.git.git_handler import GitHandler
from src.agent.agent_manager import AgentManagerFactory
from src.orchestrator.smart_fix_orchestrator import SmartFixOrchestrator

# NOTE: Google ADK appears to have issues with asyncio event loop cleanup, and has had attempts to address them in versions 1.4.0-1.5.0
# Configure warnings to ignore asyncio ResourceWarnings during shutdown
warnings.filterwarnings("ignore", category=ResourceWarning, 
                        message="unclosed.*<asyncio.sslproto._SSLProtocolTransport.*")
warnings.filterwarnings("ignore", category=ResourceWarning, 
                        message="unclosed transport")
warnings.filterwarnings("ignore", category=ResourceWarning, 
                        message="unclosed.*<asyncio.*")

# Patch asyncio to handle event loop closed errors during shutdown
_original_loop_check_closed = asyncio.base_events.BaseEventLoop._check_closed

def _patched_loop_check_closed(self):
    try:
        _original_loop_check_closed(self)
    except RuntimeError as e:
        if "Event loop is closed" in str(e):
            return  # Suppress the error
        raise
asyncio.BaseEventLoop._check_closed = _patched_loop_check_closed

# Add a specific fix for _ProactorBasePipeTransport.__del__ on Windows
if platform.system() == 'Windows':
    # Import the specific module that contains ProactorBasePipeTransport
    try:
        from asyncio.proactor_events import _ProactorBasePipeTransport
        
        # Store the original __del__ method
        _original_pipe_del = _ProactorBasePipeTransport.__del__
        
        # Define a safe replacement for __del__
        def _patched_pipe_del(self):
            try:
                # Check if the event loop is closed or finalizing
                if self._loop.is_closed() or sys.is_finalizing():
                    # Skip the original __del__ which would trigger the error
                    return

                # Otherwise use the original __del__ implementation
                _original_pipe_del(self)
            except (AttributeError, RuntimeError, ImportError, TypeError):
                # Catch and ignore all attribute or runtime errors during shutdown
                pass
        
        # Apply the patch to the __del__ method
        _ProactorBasePipeTransport.__del__ = _patched_pipe_del
        
        debug_log("Successfully patched _ProactorBasePipeTransport.__del__ for Windows")
    except (ImportError, AttributeError) as e:
        debug_log(f"Could not patch _ProactorBasePipeTransport: {str(e)}")

def cleanup_asyncio():
    """
    Cleanup function registered with atexit to properly handle asyncio resources during shutdown.
    This helps prevent the "Event loop is closed" errors during program exit.
    """
    # Suppress stderr temporarily to avoid printing shutdown errors
    original_stderr = sys.stderr
    try:
        # Create a dummy stderr to suppress errors during cleanup
        class DummyStderr:
            def write(self, *args, **kwargs):
                pass
            
            def flush(self):
                pass
        
        # Only on Windows do we need the more aggressive error suppression
        if platform.system() == 'Windows':
            sys.stderr = DummyStderr()
            
            # Windows-specific: ensure the proactor event loop resources are properly cleaned
            try:
                # Try to access the global WindowsProactorEventLoopPolicy
                loop_policy = asyncio.get_event_loop_policy()
                
                # If we have any running loops, close them properly
                try:
                    loop = loop_policy.get_event_loop()
                    if not loop.is_closed():
                        if loop.is_running():
                            loop.stop()
                        
                        # Cancel all tasks
                        pending = asyncio.all_tasks(loop)
                        if pending:
                            for task in pending:
                                task.cancel()
                            
                            # Give tasks a chance to respond to cancellation with a timeout
                            try:
                                loop.run_until_complete(asyncio.wait_for(
                                    asyncio.gather(*pending, return_exceptions=True), 
                                    timeout=1.0
                                ))
                            except (asyncio.CancelledError, asyncio.TimeoutError, Exception):
                                pass
                        
                        # Close transports and other resources
                        try:
                            loop.run_until_complete(loop.shutdown_asyncgens())
                        except Exception:
                            pass
                            
                        try:
                            loop.close()
                        except Exception:
                            pass
                except Exception:
                    pass
                    
                # Force garbage collection to ensure __del__ methods are called
                try:
                    import gc
                    gc.collect()
                except Exception:
                    pass
                    
            except Exception:
                pass  # Ignore any errors during Windows-specific cleanup
        else:
            # For non-Windows platforms, perform regular cleanup
            try:
                loop = asyncio.get_event_loop()
                if loop.is_running():
                    loop.stop()
                
                # Cancel all tasks
                pending = asyncio.all_tasks(loop)
                if pending:
                    for task in pending:
                        task.cancel()
                    
                    # Give tasks a chance to respond to cancellation
                    if not loop.is_closed():
                        loop.run_until_complete(asyncio.gather(*pending, return_exceptions=True))
                
                # Close the loop
                if not loop.is_closed():
                    loop.run_until_complete(loop.shutdown_asyncgens())
                    loop.close()
            except Exception:
                pass  # Ignore any errors during cleanup
    finally:
        # Restore stderr
        sys.stderr = original_stderr

# Register the cleanup function
import atexit
atexit.register(cleanup_asyncio)


def main():
    """Main orchestration logic using the new object-oriented structure."""
    
    start_time = datetime.now()
    log("--- Starting Contrast AI SmartFix Script ---")
    debug_log(f"Start time: {start_time.strftime('%Y-%m-%d %H:%M:%S')}")

    # --- Version Check ---
    do_version_check()
    
    # --- Initialize Configuration ---
    config = SmartFixConfig()
    
    # --- Initialize Telemetry ---
    telemetry_handler = TelemetryHandler(enable_full_telemetry=config.enable_full_telemetry)
    
    # --- Initialize API Client ---
    contrast_client = ContrastApiClient(
        host=config.contrast_host,
        org_id=config.contrast_org_id,
        app_id=config.contrast_app_id,
        auth_key=config.contrast_authorization_key,
        api_key=config.contrast_api_key,
        user_agent=config.USER_AGENT
    )
    
    # --- Initialize Git Handler ---
    git_handler = GitHandler(
        github_token=config.github_token,
        github_repository=config.github_repository,
        base_branch=config.base_branch
    )
    
    # --- Initialize Agent Manager ---
    agent_manager = AgentManagerFactory.create_production_agent_manager(telemetry_handler)
    
    # --- Initialize Orchestrator ---
    orchestrator = SmartFixOrchestrator(
        config=config,
        contrast_client=contrast_client,
        git_handler=git_handler,
        agent_manager=agent_manager,
        telemetry_handler=telemetry_handler
    )
    
    # --- Run the main process ---
    orchestrator.process_vulnerabilities()
    
    # Clean up any dangling asyncio resources
    try:
        # Force asyncio resource cleanup before exit
        loop = asyncio.get_event_loop_policy().get_event_loop()
        if not loop.is_closed():
            # Cancel all pending tasks
            pending = asyncio.all_tasks(loop)
            if pending:
                for task in pending:
                    try:
                        task.cancel()
                    except Exception:
                        pass
                
                # Give tasks a chance to respond to cancellation
                try:
                    # Wait with a timeout to prevent hanging
                    loop.run_until_complete(asyncio.gather(*pending, return_exceptions=True))
                except (asyncio.CancelledError, Exception):
                    pass
            
            try:
                # Shut down asyncgens
                loop.run_until_complete(loop.shutdown_asyncgens())
            except Exception:
                pass
                
            try:
                # Close the loop
                loop.close()
            except Exception:
                pass
                
        # On Windows, specifically force garbage collection
        if platform.system() == 'Windows':
            try:
                import gc
                gc.collect()
            except Exception:
                pass
    except Exception as e:
        # Ignore any errors during cleanup
        debug_log(f"Ignoring error during asyncio cleanup: {str(e)}")
        pass


if __name__ == "__main__":
    main()