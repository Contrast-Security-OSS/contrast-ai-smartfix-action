"""Vulnerability Processing Logic

This module contains the VulnerabilityProcessor class that handles the main
processing logic for single vulnerability remediation including workflow
coordination, context management, and remediation state transitions.

The VulnerabilityProcessor serves as the domain service for processing
individual vulnerabilities through the complete remediation workflow.
"""

from typing import Dict, Any
from datetime import datetime
import logging

from .models import Vulnerability, VulnerabilitySeverity
from .context import RemediationContext, PromptConfiguration, BuildConfiguration, RepositoryConfiguration


logger = logging.getLogger(__name__)


class VulnerabilityValidationError(Exception):
    """Exception raised when vulnerability validation fails."""
    pass


class VulnerabilityProcessingError(Exception):
    """Exception raised when vulnerability processing fails."""
    pass


class RemediationWorkflowError(Exception):
    """Exception raised when remediation workflow fails."""
    pass


class VulnerabilityProcessor:
    """
    Domain service for processing individual vulnerabilities through remediation workflow.

    The VulnerabilityProcessor handles the complete processing logic for a single
    vulnerability including workflow coordination, context management, and state
    transitions throughout the remediation process.

    This class follows Domain-Driven Design principles as a domain service,
    coordinating between the Vulnerability aggregate, RemediationContext, and
    external services to complete the remediation workflow.

    Key Responsibilities:
    - Process individual vulnerabilities through complete remediation workflow
    - Coordinate between agents (fix generation, QA, testing)
    - Manage remediation context and workflow state
    - Handle workflow transitions and error recovery
    - Provide progress tracking and telemetry integration

    Design Notes:
    - Focuses on single vulnerability processing (not batch operations)
    - Stateless service design for better testability
    - Uses RemediationContext for maintaining workflow state
    - Integrates with external agents and services
    - Implements comprehensive error handling and recovery
    """

    def __init__(self, **kwargs):
        """
        Initialize a new VulnerabilityProcessor instance.

        Args:
            **kwargs: Additional processor configuration options
        """
        self._config = kwargs

        logger.info("VulnerabilityProcessor initialized for single vulnerability processing")

    def validate_vulnerability(self, vulnerability: Vulnerability) -> bool:
        """
        Validate a vulnerability for processing eligibility.

        Applies business rules to determine if a vulnerability should be
        processed for remediation including basic data validation and
        business criteria checks.

        Args:
            vulnerability: Vulnerability to validate

        Returns:
            True if vulnerability is valid for processing, False otherwise

        Raises:
            VulnerabilityValidationError: If validation fails with specific error
        """
        try:
            # Validate basic vulnerability data integrity
            if not vulnerability.uuid:
                raise VulnerabilityValidationError("Vulnerability UUID is required")

            if not vulnerability.title:
                raise VulnerabilityValidationError("Vulnerability title is required")

            # Note: Status-based validation removed since status is optional and not used in main workflow

            # Validate severity is within acceptable range for processing
            if vulnerability.severity == VulnerabilitySeverity.NOTE:
                logger.info(f"Vulnerability {vulnerability.uuid} has NOTE severity, may skip based on configuration")

            # Validate rule name exists (required for processing)
            if not vulnerability.rule_name:
                raise VulnerabilityValidationError("Vulnerability rule name is required")

            logger.info(f"Vulnerability {vulnerability.uuid} passed validation")
            return True

        except Exception as e:
            logger.error(f"Validation error for vulnerability {vulnerability.uuid}: {e}")
            raise VulnerabilityValidationError(f"Validation failed: {e}") from e

    def create_remediation_context(
        self,
        remediation_id: str,
        vulnerability: Vulnerability,
        prompts: PromptConfiguration,
        build_config: BuildConfiguration,
        repo_config: RepositoryConfiguration,
        **kwargs
    ) -> RemediationContext:
        """
        Create a remediation context for processing a vulnerability.

        Args:
            remediation_id: API-provided remediation ID for tracking
            vulnerability: Vulnerability to create context for
            prompts: AI prompts configuration
            build_config: Build and testing configuration
            repo_config: Repository configuration
            **kwargs: Additional context metadata

        Returns:
            New RemediationContext configured for the vulnerability

        Raises:
            VulnerabilityProcessingError: If context creation fails
        """
        try:
            # Validate vulnerability before creating context
            if not self.validate_vulnerability(vulnerability):
                raise VulnerabilityProcessingError(f"Vulnerability {vulnerability.uuid} failed validation")

            # Create and return context using API-provided remediation ID
            context = RemediationContext(
                remediation_id=remediation_id,
                vulnerability=vulnerability,
                prompts=prompts,
                build_config=build_config,
                repo_config=repo_config
            )

            logger.info(f"Created remediation context {remediation_id} for vulnerability {vulnerability.uuid}")
            return context

        except Exception as e:
            error_msg = f"Failed to create remediation context for vulnerability {vulnerability.uuid}: {e}"
            logger.error(error_msg)
            raise VulnerabilityProcessingError(error_msg) from e


    def process_api_vulnerability_data(self, api_data: Dict[str, Any]) -> Vulnerability:
        """
        Process vulnerability data from external API.

        Transforms raw API data into a validated Vulnerability domain object
        with proper error handling and data validation.

        Args:
            api_data: Raw vulnerability data from external API

        Returns:
            New Vulnerability instance

        Raises:
            VulnerabilityProcessingError: If API data processing fails
        """
        try:
            # Use the Vulnerability.from_api_data class method for conversion
            vulnerability = Vulnerability.from_api_data(api_data)

            logger.info(f"Successfully processed API data for vulnerability {vulnerability.uuid}")
            return vulnerability

        except (KeyError, ValueError) as e:
            error_msg = f"Failed to process API vulnerability data: {e}"
            logger.error(error_msg)
            raise VulnerabilityProcessingError(error_msg) from e

    def __str__(self) -> str:
        """String representation of the processor."""
        return f"VulnerabilityProcessor(config_keys={len(self._config)})"

    def __repr__(self) -> str:
        """Debug representation of the processor."""
        return f"VulnerabilityProcessor(config={self._config})"
