"""Remediation Context Management

This module contains the RemediationContext class that encapsulates all
the contextual information needed for vulnerability remediation including
prompts, configuration, repository information, and workflow state.

The RemediationContext serves as a value object that maintains all the
necessary context for the remediation process.
"""

from typing import Optional, Union, List
from pathlib import Path
from dataclasses import dataclass

from .models import Vulnerability

# Import configuration for prompt processing
from src.config import get_config


@dataclass
class PromptConfiguration:
    """Configuration for AI agent prompts used in vulnerability remediation."""
    fix_system_prompt: Optional[str] = None
    fix_user_prompt: Optional[str] = None
    qa_system_prompt: Optional[str] = None
    qa_user_prompt: Optional[str] = None

    def validate(self, require_all_prompts: bool = True) -> None:
        """
        Validate prompts based on agent type requirements.

        Args:
            require_all_prompts: If True, all prompts are required (SmartFix agents).
                                If False, prompts are optional (external agents).

        Raises:
            ValueError: If required prompts are missing or empty
        """
        if require_all_prompts:
            # SmartFix agents require all prompts
            if not self.fix_system_prompt:
                raise ValueError("Fix system prompt is required for SmartFix agents")
            if not self.fix_user_prompt:
                raise ValueError("Fix user prompt is required for SmartFix agents")
            if not self.qa_system_prompt:
                raise ValueError("QA system prompt is required for SmartFix agents")
            if not self.qa_user_prompt:
                raise ValueError("QA user prompt is required for SmartFix agents")
        # For external agents, prompts are optional - no validation needed

    def has_fix_prompts(self) -> bool:
        """Check if fix prompts are available."""
        return bool(self.fix_system_prompt and self.fix_user_prompt)

    def has_qa_prompts(self) -> bool:
        """Check if QA prompts are available."""
        return bool(self.qa_system_prompt and self.qa_user_prompt)

    def get_processed_fix_user_prompt(self) -> Optional[str]:
        """
        Get the processed fix user prompt with SecurityTest removal if configured.

        Returns:
            Processed fix user prompt, or None if no fix user prompt is available
        """
        if not self.fix_user_prompt:
            return None

        config = get_config()
        processed_prompt = self.fix_user_prompt

        if config.SKIP_WRITING_SECURITY_TEST:
            start_str = "4. Where feasible,"
            end_str = "   - **CRITICAL: When mocking"
            replacement_text = ("4. Where feasible, add or update tests to verify the fix.\n"
                                "    - **Use the 'Original HTTP Request' provided above as a basis for creating "
                                "realistic mocked input data or request parameters within your test case.** "
                                "Adapt the request details (method, path, headers, body) as needed for the "
                                "test framework (e.g., MockMvc in Spring).\n")

            start_index = processed_prompt.find(start_str)
            end_index = processed_prompt.find(end_str)

            if start_index != -1 and end_index != -1:
                processed_prompt = (
                    processed_prompt[:start_index] + replacement_text + processed_prompt[end_index:]
                )

        return processed_prompt

    def get_processed_qa_user_prompt(
        self,
        changed_files: List[str],
        build_output: str,
        qa_history_section: str
    ) -> Optional[str]:
        """
        Get the processed QA user prompt with placeholder replacements.

        Args:
            changed_files: List of files that were changed by the fix agent
            build_output: The build command output
            qa_history_section: Formatted QA history from previous attempts

        Returns:
            Processed QA user prompt, or None if no QA user prompt is available
        """
        if not self.qa_user_prompt:
            return None

        # Replace placeholders
        processed_prompt = self.qa_user_prompt.replace("{changed_files}", ', '.join(changed_files))
        processed_prompt = processed_prompt.replace("{build_output}", build_output)
        processed_prompt = processed_prompt.replace("{qa_history_section}", qa_history_section)

        return processed_prompt

    @classmethod
    def for_smartfix_agent(
        cls,
        fix_system_prompt: str,
        fix_user_prompt: str,
        qa_system_prompt: str,
        qa_user_prompt: str
    ) -> "PromptConfiguration":
        """Create configuration for SmartFix agents with processed prompts."""
        config = cls(
            fix_system_prompt=fix_system_prompt,
            fix_user_prompt=fix_user_prompt,
            qa_system_prompt=qa_system_prompt,
            qa_user_prompt=qa_user_prompt
        )

        # Process fix user prompt during configuration
        config.fix_user_prompt = config.get_processed_fix_user_prompt()

        config.validate(require_all_prompts=True)
        return config

    @classmethod
    def for_external_agent(cls) -> "PromptConfiguration":
        """Create configuration for external agents (no prompts required)."""
        return cls(
            fix_system_prompt=None,
            fix_user_prompt=None,
            qa_system_prompt=None,
            qa_user_prompt=None
        )

    @classmethod
    def from_config(cls, config) -> "PromptConfiguration":
        """
        Create PromptConfiguration from application config.

        Args:
            config: Application configuration object

        Returns:
            New PromptConfiguration instance
        """
        return cls(
            fix_system_prompt=getattr(config, 'FIX_SYSTEM_PROMPT', None),
            fix_user_prompt=getattr(config, 'FIX_USER_PROMPT', None),
            qa_system_prompt=getattr(config, 'QA_SYSTEM_PROMPT', None),
            qa_user_prompt=getattr(config, 'QA_USER_PROMPT', None)
        )


@dataclass
class BuildConfiguration:
    """Configuration for build and formatting commands."""
    build_command: Optional[str] = None
    formatting_command: Optional[str] = None

    @classmethod
    def from_config(cls, config) -> 'BuildConfiguration':
        """Create BuildConfiguration from application config."""
        return cls(
            build_command=config.BUILD_COMMAND,
            formatting_command=config.FORMATTING_COMMAND
        )

    def has_build_command(self) -> bool:
        """Check if build command is configured."""
        return bool(self.build_command and self.build_command.strip())

    def has_formatting_command(self) -> bool:
        """Check if formatting command is configured."""
        return bool(self.formatting_command and self.formatting_command.strip())


@dataclass
class RepositoryConfiguration:
    """Configuration for repository and SCM operations."""
    repo_path: Union[str, Path]
    base_branch: str
    working_branch: Optional[str] = None
    remote_url: Optional[str] = None

    def __post_init__(self):
        """Convert repo_path to Path object after initialization."""
        self.repo_path = Path(self.repo_path)

    def validate(self) -> None:
        """
        Validate repository configuration.

        Raises:
            ValueError: If configuration is invalid
        """
        if not self.base_branch:
            raise ValueError("Base branch is required")
        if not self.repo_path.exists():
            raise ValueError(f"Repository path does not exist: {self.repo_path}")

    def is_valid_repo(self) -> bool:
        """Check if the repository path exists and is valid."""
        return self.repo_path.exists() and (self.repo_path / '.git').exists()

    @classmethod
    def from_config(cls, config) -> "RepositoryConfiguration":
        """
        Create RepositoryConfiguration from application config.

        Args:
            config: Application configuration object

        Returns:
            Configured RepositoryConfiguration instance
        """
        return cls(
            repo_path=config.REPO_ROOT,
            base_branch=config.BASE_BRANCH,
            working_branch=getattr(config, 'WORKING_BRANCH', None),
            remote_url=getattr(config, 'REMOTE_URL', None)
        )


@dataclass(frozen=True)
class RemediationContext:
    """
    Simple container for vulnerability remediation workflow context.

    Groups related configuration objects together for clean parameter passing
    and maintains the relationship between vulnerability and its configuration.
    """

    remediation_id: str
    vulnerability: Vulnerability
    prompts: PromptConfiguration
    build_config: BuildConfiguration
    repo_config: RepositoryConfiguration

    @classmethod
    def create(
        cls,
        remediation_id: str,
        vulnerability: Vulnerability,
        config
    ) -> 'RemediationContext':
        """
        Create RemediationContext from remediation ID, vulnerability, and application config.

        Args:
            remediation_id: Unique identifier for this remediation attempt
            vulnerability: The vulnerability to remediate
            config: Application configuration object

        Returns:
            New RemediationContext instance
        """
        return cls(
            remediation_id=remediation_id,
            vulnerability=vulnerability,
            prompts=PromptConfiguration.from_config(config),
            build_config=BuildConfiguration.from_config(config),
            repo_config=RepositoryConfiguration.from_config(config)
        )
