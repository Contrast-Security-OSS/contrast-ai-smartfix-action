"""Remediation Context Management

This module contains the RemediationContext class that encapsulates all
the contextual information needed for vulnerability remediation including
prompts, configuration, repository information, and workflow state.

The RemediationContext serves as a value object that maintains all the
necessary context for the remediation process.
"""

from typing import Optional, Union, List
from pathlib import Path
from dataclasses import dataclass

from .models import Vulnerability

# Import configuration for prompt processing
from src.config import get_config


@dataclass
class PromptConfiguration:
    """Configuration for AI agent prompts used in vulnerability remediation."""
    fix_system_prompt: Optional[str] = None
    fix_user_prompt: Optional[str] = None
    qa_system_prompt: Optional[str] = None
    qa_user_prompt: Optional[str] = None

    def validate(self, require_all_prompts: bool = True) -> None:
        """
        Validate prompts based on agent type requirements.

        Args:
            require_all_prompts: If True, all prompts are required (SmartFix agents).
                                If False, prompts are optional (external agents).

        Raises:
            ValueError: If required prompts are missing or empty
        """
        if require_all_prompts:
            missing_prompts = []
            if not self.fix_system_prompt:
                missing_prompts.append("fix_system_prompt")
            if not self.fix_user_prompt:
                missing_prompts.append("fix_user_prompt")
            if not self.qa_system_prompt:
                missing_prompts.append("qa_system_prompt")
            if not self.qa_user_prompt:
                missing_prompts.append("qa_user_prompt")
            if missing_prompts:
                raise ValueError(f"Missing required prompts for SmartFix agents: {', '.join(missing_prompts)}")

    def has_fix_prompts(self) -> bool:
        """Check if fix prompts are available."""
        return bool(self.fix_system_prompt and self.fix_user_prompt)

    def has_qa_prompts(self) -> bool:
        """Check if QA prompts are available."""
        return bool(self.qa_system_prompt and self.qa_user_prompt)

    def get_processed_fix_user_prompt(self) -> Optional[str]:
        """
        Get the processed fix user prompt with SecurityTest removal if configured.

        Returns:
            Processed fix user prompt, or None if no fix user prompt is available
        """
        if not self.fix_user_prompt:
            return None

        processed_prompt = self.fix_user_prompt

        # Apply security test removal if configured
        if get_config().SKIP_WRITING_SECURITY_TEST:
            processed_prompt = self._replace_security_test_section(processed_prompt)

        return processed_prompt

    def get_processed_qa_user_prompt(
        self,
        changed_files: List[str],
        build_output: str,
        qa_history_section: str
    ) -> Optional[str]:
        """
        Get the processed QA user prompt with placeholder replacements.

        Args:
            changed_files: List of files that were changed by the fix agent
            build_output: The build command output
            qa_history_section: Formatted QA history from previous attempts

        Returns:
            Processed QA user prompt, or None if no QA user prompt is available
        """
        if not self.qa_user_prompt:
            return None

        # Replace placeholders using format-like replacements
        replacements = {
            "{changed_files}": ', '.join(changed_files),
            "{build_output}": build_output,
            "{qa_history_section}": qa_history_section
        }

        processed_prompt = self.qa_user_prompt
        for placeholder, value in replacements.items():
            processed_prompt = processed_prompt.replace(placeholder, value)

        return processed_prompt

    def _replace_security_test_section(self, prompt: str) -> str:
        """
        Replace the security test section in the prompt when SKIP_WRITING_SECURITY_TEST is True.

        Args:
            prompt: The original prompt text

        Returns:
            Prompt with security test section replaced
        """
        start_marker = "4. Where feasible,"
        end_marker = "   - **CRITICAL: When mocking"
        replacement = (
            "4. Where feasible, add or update tests to verify the fix.\n"
            "    - **Use the 'Original HTTP Request' provided above as a basis for creating "
            "realistic mocked input data or request parameters within your test case.** "
            "Adapt the request details (method, path, headers, body) as needed for the "
            "test framework (e.g., MockMvc in Spring).\n"
        )

        start_pos = prompt.find(start_marker)
        end_pos = prompt.find(end_marker)

        if start_pos != -1 and end_pos != -1:
            return prompt[:start_pos] + replacement + prompt[end_pos:]

        return prompt

    @classmethod
    def validate_raw_prompts_data(cls, prompts_data: dict) -> bool:
        """
        Validate raw prompts data dictionary for SmartFix agents.

        Args:
            prompts_data: Dictionary containing prompt data from backend

        Returns:
            bool: True if valid

        Raises:
            ValueError: If prompts are invalid/missing
        """
        required_prompts = ['fixSystemPrompt', 'fixUserPrompt', 'qaSystemPrompt', 'qaUserPrompt']

        for prompt_key in required_prompts:
            if prompt_key not in prompts_data:
                raise ValueError(f"Missing required prompt key: {prompt_key}")

            prompt_value = prompts_data[prompt_key]
            if not prompt_value or not prompt_value.strip():
                raise ValueError(f"Missing or empty required prompt: {prompt_key}")

        return True

    @classmethod
    def for_smartfix_agent(
        cls,
        fix_system_prompt: str,
        fix_user_prompt: str,
        qa_system_prompt: str,
        qa_user_prompt: str
    ) -> "PromptConfiguration":
        """Create configuration for SmartFix agents with processed prompts."""
        config = cls(
            fix_system_prompt=fix_system_prompt,
            fix_user_prompt=fix_user_prompt,
            qa_system_prompt=qa_system_prompt,
            qa_user_prompt=qa_user_prompt
        )

        # Process fix user prompt during configuration
        config.fix_user_prompt = config.get_processed_fix_user_prompt()

        config.validate(require_all_prompts=True)
        return config

    @classmethod
    def for_external_agent(cls) -> "PromptConfiguration":
        """Create configuration for external agents (no prompts required)."""
        return cls(
            fix_system_prompt=None,
            fix_user_prompt=None,
            qa_system_prompt=None,
            qa_user_prompt=None
        )

    @classmethod
    def from_config(cls, config) -> "PromptConfiguration":
        """
        Create PromptConfiguration from application config.

        Args:
            config: Application configuration object

        Returns:
            New PromptConfiguration instance
        """
        return cls(
            fix_system_prompt=getattr(config, 'FIX_SYSTEM_PROMPT', None),
            fix_user_prompt=getattr(config, 'FIX_USER_PROMPT', None),
            qa_system_prompt=getattr(config, 'QA_SYSTEM_PROMPT', None),
            qa_user_prompt=getattr(config, 'QA_USER_PROMPT', None)
        )


@dataclass
class BuildConfiguration:
    """Configuration for build and formatting commands."""
    build_command: Optional[str] = None
    formatting_command: Optional[str] = None

    @classmethod
    def from_config(cls, config) -> 'BuildConfiguration':
        """Create BuildConfiguration from application config."""
        return cls(
            build_command=config.BUILD_COMMAND,
            formatting_command=config.FORMATTING_COMMAND
        )

    def has_build_command(self) -> bool:
        """Check if build command is configured."""
        return bool(self.build_command and self.build_command.strip())

    def has_formatting_command(self) -> bool:
        """Check if formatting command is configured."""
        return bool(self.formatting_command and self.formatting_command.strip())


@dataclass
class RepositoryConfiguration:
    """Configuration for repository and SCM operations."""
    repo_path: Union[str, Path]
    base_branch: str
    working_branch: Optional[str] = None
    remote_url: Optional[str] = None

    def __post_init__(self):
        """Convert repo_path to Path object after initialization."""
        self.repo_path = Path(self.repo_path)

    def validate(self) -> None:
        """Validate repository configuration. Removed premature validation - kept for test compatibility."""
        pass

    def is_valid_repo(self) -> bool:
        """Check if the repository path exists and is valid."""
        return self.repo_path.exists() and (self.repo_path / '.git').exists()

    @classmethod
    def from_config(cls, config) -> "RepositoryConfiguration":
        """
        Create RepositoryConfiguration from application config.

        Args:
            config: Application configuration object

        Returns:
            Configured RepositoryConfiguration instance
        """
        return cls(
            repo_path=config.REPO_ROOT,
            base_branch=config.BASE_BRANCH,
            working_branch=getattr(config, 'WORKING_BRANCH', None),
            remote_url=getattr(config, 'REMOTE_URL', None)
        )


@dataclass
class RemediationContext:
    """
    Simple container for vulnerability remediation workflow context.

    Groups related configuration objects together for clean parameter passing
    and maintains the relationship between vulnerability and its configuration.
    """

    remediation_id: str
    vulnerability: Vulnerability
    prompts: PromptConfiguration
    build_config: BuildConfiguration
    repo_config: RepositoryConfiguration
    max_qa_attempts: int = 6
    skip_writing_security_test: bool = False
    session_id: Optional[str] = None

    @classmethod
    def from_config(
        cls,
        remediation_id: str,
        vulnerability: Vulnerability,
        config,
        prompts: Optional[PromptConfiguration] = None,
        session_id: Optional[str] = None
    ) -> 'RemediationContext':
        """
        Create complete RemediationContext from application config - single source of truth.

        Args:
            remediation_id: Unique identifier for this remediation attempt
            vulnerability: The vulnerability to remediate
            config: Application configuration object
            prompts: Optional pre-configured prompts (e.g., from API). If None, loads from config.
            session_id: Optional LLM proxy session ID for Contrast LLM integration

        Returns:
            New RemediationContext instance with all components configured

        Raises:
            ValueError: If context creation fails
        """
        import logging
        logger = logging.getLogger(__name__)

        try:
            context = cls(
                remediation_id=remediation_id,
                vulnerability=vulnerability,
                prompts=prompts if prompts else PromptConfiguration.from_config(config),
                build_config=BuildConfiguration.from_config(config),
                repo_config=RepositoryConfiguration.from_config(config),
                max_qa_attempts=config.MAX_QA_ATTEMPTS,
                skip_writing_security_test=config.SKIP_WRITING_SECURITY_TEST,
                session_id=session_id
            )

            logger.info(f"Created remediation context {remediation_id} for vulnerability {vulnerability.uuid}")
            return context

        except Exception as e:
            error_msg = f"Failed to create remediation context for vulnerability {vulnerability.uuid}: {e}"
            logger.error(error_msg)
            raise ValueError(error_msg) from e
