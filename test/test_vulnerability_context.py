#!/usr/bin/env python3
"""Unit tests for RemediationContext creation methods.

This module tests the RemediationContext functionality including:
- Vulnerability data processing from API responses
- Domain object creation and validation
- Context management for remediation workflows
- Error handling and validation
"""

import unittest
from pathlib import Path

# Test setup imports (path is set up by conftest.py)
from src.smartfix.domains.vulnerability.context import (
    RemediationContext, PromptConfiguration, BuildConfiguration, RepositoryConfiguration
)
from src.smartfix.domains.vulnerability.models import (
    Vulnerability, VulnerabilitySeverity
)
from setup_test_env import create_temp_repo_dir


class TestRemediationContextCreation(unittest.TestCase):
    """Test cases for RemediationContext creation methods."""

    def setUp(self):
        """Set up test environment."""
        pass

    def tearDown(self):
        """Clean up test environment."""
        pass

    def test_basic_creation(self):
        """Test basic PromptConfiguration creation."""
        prompts = PromptConfiguration(
            fix_system_prompt="Fix system prompt",
            fix_user_prompt="Fix user prompt",
            qa_system_prompt="QA system prompt",
            qa_user_prompt="QA user prompt"
        )

        self.assertEqual(prompts.fix_system_prompt, "Fix system prompt")
        self.assertEqual(prompts.fix_user_prompt, "Fix user prompt")
        self.assertEqual(prompts.qa_system_prompt, "QA system prompt")
        self.assertEqual(prompts.qa_user_prompt, "QA user prompt")

    def test_validation_required_fields(self):
        """Test validation of required prompt fields for SmartFix agents."""
        # Test missing fix_system_prompt for SmartFix
        with self.assertRaises(ValueError):
            prompts = PromptConfiguration(
                fix_system_prompt="",
                fix_user_prompt="Fix user prompt",
                qa_system_prompt="QA system prompt",
                qa_user_prompt="QA user prompt"
            )
            prompts.validate(require_all_prompts=True)

        # Test missing fix_user_prompt for SmartFix
        with self.assertRaises(ValueError):
            prompts = PromptConfiguration(
                fix_system_prompt="Fix system prompt",
                fix_user_prompt="",
                qa_system_prompt="QA system prompt",
                qa_user_prompt="QA user prompt"
            )
            prompts.validate(require_all_prompts=True)

    def test_external_agent_validation(self):
        """Test that external agents don't require prompts."""
        # External agents can have None prompts
        prompts = PromptConfiguration()  # All None by default
        prompts.validate(require_all_prompts=False)  # Should not raise

        # Test factory method for external agents
        external_prompts = PromptConfiguration.for_external_agent()
        external_prompts.validate(require_all_prompts=False)
        self.assertIsNone(external_prompts.fix_system_prompt)
        self.assertIsNone(external_prompts.qa_system_prompt)

    def test_smartfix_agent_factory(self):
        """Test SmartFix agent factory method."""
        prompts = PromptConfiguration.for_smartfix_agent(
            fix_system_prompt="Fix system prompt",
            fix_user_prompt="Fix user prompt",
            qa_system_prompt="QA system prompt",
            qa_user_prompt="QA user prompt"
        )

        self.assertEqual(prompts.fix_system_prompt, "Fix system prompt")
        self.assertEqual(prompts.qa_user_prompt, "QA user prompt")
        self.assertTrue(prompts.has_fix_prompts())
        self.assertTrue(prompts.has_qa_prompts())

    def test_prompt_availability_checks(self):
        """Test prompt availability check methods."""
        # Configuration with fix prompts only
        fix_only = PromptConfiguration(
            fix_system_prompt="Fix system",
            fix_user_prompt="Fix user"
        )
        self.assertTrue(fix_only.has_fix_prompts())
        self.assertFalse(fix_only.has_qa_prompts())

        # Configuration with no prompts
        no_prompts = PromptConfiguration()
        self.assertFalse(no_prompts.has_fix_prompts())
        self.assertFalse(no_prompts.has_qa_prompts())

    def test_optional_qa_prompts(self):
        """Test creation with optional prompts."""
        # Test that prompts can now be optional
        prompts = PromptConfiguration(
            fix_system_prompt="Fix system prompt",
            fix_user_prompt="Fix user prompt"
            # qa prompts are optional now
        )

        self.assertEqual(prompts.fix_system_prompt, "Fix system prompt")
        self.assertEqual(prompts.fix_user_prompt, "Fix user prompt")
        self.assertIsNone(prompts.qa_system_prompt)
        self.assertIsNone(prompts.qa_user_prompt)


class TestBuildConfiguration(unittest.TestCase):
    """Test cases for BuildConfiguration value object."""

    def test_basic_creation(self):
        """Test basic BuildConfiguration creation."""
        build_config = BuildConfiguration(
            build_command="npm test"
        )

        self.assertEqual(build_config.build_command, "npm test")
        self.assertIsNone(build_config.formatting_command)

    def test_full_creation(self):
        """Test BuildConfiguration creation with all fields."""
        build_config = BuildConfiguration(
            build_command="gradle test",
            formatting_command="gradle spotlessApply"
        )

        self.assertEqual(build_config.build_command, "gradle test")
        self.assertEqual(build_config.formatting_command, "gradle spotlessApply")

    def test_validation(self):
        """Test BuildConfiguration validation methods."""
        # Test with build command
        config = BuildConfiguration(build_command="test")
        self.assertTrue(config.has_build_command())

        # Test without build command
        config = BuildConfiguration()
        self.assertFalse(config.has_build_command())

        # Test with formatting command
        config = BuildConfiguration(formatting_command="format")
        self.assertTrue(config.has_formatting_command())

        # Test without formatting command
        config = BuildConfiguration()
        self.assertFalse(config.has_formatting_command())

    def test_formatting_command_handling(self):
        """Test formatting command handling."""
        # With formatting command
        config_with_formatting = BuildConfiguration(
            build_command="test",
            formatting_command="format"
        )
        self.assertEqual(config_with_formatting.formatting_command, "format")

        # Without formatting command
        config_without_formatting = BuildConfiguration(build_command="test")
        self.assertIsNone(config_without_formatting.formatting_command)


class TestRepositoryConfiguration(unittest.TestCase):
    """Test cases for RepositoryConfiguration value object."""

    def test_basic_creation(self):
        """Test basic RepositoryConfiguration creation."""
        repo_config = RepositoryConfiguration(
            repo_path=Path("/path/to/repo"),
            base_branch="main"
        )

        self.assertEqual(repo_config.repo_path, Path("/path/to/repo"))
        self.assertEqual(repo_config.base_branch, "main")
        self.assertIsNone(repo_config.working_branch)
        self.assertIsNone(repo_config.remote_url)

    def test_full_creation(self):
        """Test RepositoryConfiguration creation with all fields."""
        repo_config = RepositoryConfiguration(
            repo_path=Path("/app/code"),
            base_branch="main",
            working_branch="feature/vulnerability-fix",
            remote_url="https://github.com/company/project"
        )

        self.assertEqual(repo_config.repo_path, Path("/app/code"))
        self.assertEqual(repo_config.base_branch, "main")
        self.assertEqual(repo_config.working_branch, "feature/vulnerability-fix")
        self.assertEqual(repo_config.remote_url, "https://github.com/company/project")

    def test_validation(self):
        """Test RepositoryConfiguration validation - simplified (no premature validation)."""
        # Test that validation doesn't raise errors (premature validation removed)
        config = RepositoryConfiguration(
            repo_path=Path("/path"),
            base_branch=""
        )
        # Should not raise any errors since premature validation was removed
        config.validate()

    def test_path_conversion(self):
        """Test that string paths are converted to Path objects."""
        repo_config = RepositoryConfiguration(
            repo_path="/string/path",
            base_branch="main"
        )

        self.assertIsInstance(repo_config.repo_path, Path)
        self.assertEqual(repo_config.repo_path, Path("/string/path"))


class TestRemediationContext(unittest.TestCase):
    """Test cases for RemediationContext aggregate root."""

    def setUp(self):
        """Set up test fixtures."""
        # Get test config
        from src.config import get_config, reset_config
        reset_config()
        self.config = get_config(testing=True)

        # Use helper for temp directory creation
        self.temp_dir = str(create_temp_repo_dir())

        # Create test vulnerability without location
        self.vulnerability = Vulnerability(
            uuid="vuln-123-456-789",
            title="Test Vulnerability",
            rule_name="test-rule",
            severity=VulnerabilitySeverity.HIGH
        )

        self.prompts = PromptConfiguration(
            fix_system_prompt='Test fix system prompt',
            fix_user_prompt='Test fix user prompt',
            qa_system_prompt='Test QA system prompt',
            qa_user_prompt='Test QA user prompt'
        )

        self.build_config = BuildConfiguration(
            build_command='npm test',
            formatting_command='npm run format'
        )

        self.repo_config = RepositoryConfiguration(
            repo_path='/test/workspace',
            base_branch='main',
            working_branch='fix-branch',
            remote_url='https://github.com/test/repo.git'
        )

        # Create a valid test vulnerability
        self.valid_vulnerability = Vulnerability(
            uuid="test-vuln-123",
            title="Test Vulnerability",
            rule_name="test-rule",
            severity=VulnerabilitySeverity.MEDIUM,
            description="A test vulnerability for unit testing"
        )

        # Sample API data for testing
        self.sample_api_data = {
            'remediationId': 'api-remediation-456',
            'vulnerabilityUuid': 'api-vuln-456',
            'vulnerabilityTitle': 'API Vulnerability',
            'vulnerabilityRuleName': 'api-rule',
            'vulnerabilityStatus': 'OPEN',
            'vulnerabilitySeverity': 'HIGH',
            'file': 'api_test.py',
            'lineNumber': 100
        }

    def test_create_with_components_success(self):
        """Test successful creation of remediation context with explicit prompts."""
        api_provided_id = "api-remediation-789"

        context = RemediationContext.from_config(
            remediation_id=api_provided_id,
            vulnerability=self.valid_vulnerability,
            config=self.config,
            prompts=self.prompts
        )

        self.assertIsInstance(context, RemediationContext)
        self.assertEqual(context.remediation_id, api_provided_id)
        self.assertEqual(context.vulnerability, self.valid_vulnerability)
        self.assertEqual(context.prompts, self.prompts)
        self.assertIsNotNone(context.build_config)
        self.assertIsNotNone(context.repo_config)
        self.assertEqual(context.max_qa_attempts, self.config.MAX_QA_ATTEMPTS)
        self.assertEqual(context.skip_writing_security_test, self.config.SKIP_WRITING_SECURITY_TEST)
        self.assertIsNone(context.session_id)  # Should be None when not provided

    def test_create_with_components_validation_error(self):
        """Test context creation with invalid vulnerability raises appropriate error."""
        # Test that the Vulnerability validation works during construction
        with self.assertRaises(ValueError) as context_manager:
            # This should fail during vulnerability validation in __post_init__
            Vulnerability(
                uuid="",  # Invalid empty UUID
                title="Test Vulnerability",
                rule_name="test-rule",
                severity=VulnerabilitySeverity.MEDIUM
            )

        # Verify the error message is about the UUID
        self.assertIn("UUID is required", str(context_manager.exception))

    def test_create_with_components_success_with_logging(self):
        """Test that context creation logs the expected success message."""
        # Capture log output
        with self.assertLogs(level='INFO') as log_capture:
            context = RemediationContext.from_config(
                remediation_id="test-logging-id",
                vulnerability=self.valid_vulnerability,
                config=self.config,
                prompts=self.prompts
            )

        # Verify context was created successfully
        self.assertIsInstance(context, RemediationContext)
        self.assertEqual(context.remediation_id, "test-logging-id")

        # Verify the success log message was generated
        log_messages = [record.message for record in log_capture.records]
        success_message_found = any(
            "Created remediation context test-logging-id for vulnerability test-vuln-123" in msg
            for msg in log_messages
        )
        self.assertTrue(success_message_found, f"Expected success log message not found in: {log_messages}")

    def test_create_with_session_id(self):
        """Test successful creation of remediation context with session_id."""
        api_provided_id = "api-remediation-789"
        test_session_id = "test-session-123"

        context = RemediationContext.from_config(
            remediation_id=api_provided_id,
            vulnerability=self.valid_vulnerability,
            config=self.config,
            prompts=self.prompts,
            session_id=test_session_id
        )

        self.assertIsInstance(context, RemediationContext)
        self.assertEqual(context.remediation_id, api_provided_id)
        self.assertEqual(context.vulnerability, self.valid_vulnerability)
        self.assertEqual(context.prompts, self.prompts)
        self.assertEqual(context.session_id, test_session_id)
        self.assertIsNotNone(context.build_config)
        self.assertIsNotNone(context.repo_config)

    def test_create_without_session_id_defaults_to_none(self):
        """Test that session_id defaults to None when not provided."""
        api_provided_id = "api-remediation-456"

        context = RemediationContext.from_config(
            remediation_id=api_provided_id,
            vulnerability=self.valid_vulnerability,
            config=self.config,
            prompts=self.prompts
            # No session_id provided
        )

        self.assertIsInstance(context, RemediationContext)
        self.assertEqual(context.session_id, None)


if __name__ == '__main__':
    unittest.main()
