#!/usr/bin/env python3
"""Unit tests for RemediationContext creation methods.

This module tests the RemediationContext functionality including:
- Vulnerability data processing from API responses
- Domain object creation and validation
- Context management for remediation workflows
- Error handling and validation
"""

import unittest

# Test setup imports (path is set up by conftest.py)
from src.smartfix.domains.vulnerability.context import (
    RemediationContext, PromptConfiguration, BuildConfiguration, RepositoryConfiguration
)
from src.smartfix.domains.vulnerability.models import (
    Vulnerability, VulnerabilitySeverity
)


class TestRemediationContextCreation(unittest.TestCase):
    """Test cases for RemediationContext creation methods."""

    def setUp(self):
        """Set up test environment."""
        # Create valid test configuration objects using direct construction
        self.prompts = PromptConfiguration(
            fix_system_prompt='Test fix system prompt',
            fix_user_prompt='Test fix user prompt',
            qa_system_prompt='Test QA system prompt',
            qa_user_prompt='Test QA user prompt'
        )

        self.build_config = BuildConfiguration(
            build_command='npm test',
            formatting_command='npm run format'
        )

        self.repo_config = RepositoryConfiguration(
            repo_path='/test/workspace',
            base_branch='main',
            working_branch='fix-branch',
            remote_url='https://github.com/test/repo.git'
        )

        # Create a valid test vulnerability
        self.valid_vulnerability = Vulnerability(
            uuid="test-vuln-123",
            title="Test Vulnerability",
            rule_name="test-rule",
            severity=VulnerabilitySeverity.MEDIUM,
            remediation_id="test-remediation-123",
            description="A test vulnerability for unit testing"
        )

        # Sample API data for testing
        self.sample_api_data = {
            'remediationId': 'api-remediation-456',
            'vulnerabilityUuid': 'api-vuln-456',
            'vulnerabilityTitle': 'API Vulnerability',
            'vulnerabilityRuleName': 'api-rule',
            'vulnerabilityStatus': 'OPEN',
            'vulnerabilitySeverity': 'HIGH',
            'file': 'api_test.py',
            'lineNumber': 100
        }

    def test_create_with_components_success(self):
        """Test successful creation of remediation context with pre-configured components."""
        api_provided_id = "api-remediation-789"

        context = RemediationContext.create_with_components(
            remediation_id=api_provided_id,
            vulnerability=self.valid_vulnerability,
            prompts=self.prompts,
            build_config=self.build_config,
            repo_config=self.repo_config
        )

        self.assertIsInstance(context, RemediationContext)
        self.assertEqual(context.remediation_id, api_provided_id)
        self.assertEqual(context.vulnerability, self.valid_vulnerability)
        self.assertEqual(context.prompts, self.prompts)
        self.assertEqual(context.build_config, self.build_config)
        self.assertEqual(context.repo_config, self.repo_config)

    def test_create_with_components_validation_error(self):
        """Test context creation with invalid vulnerability raises appropriate error."""
        # Test that the Vulnerability validation works during construction
        with self.assertRaises(ValueError) as context_manager:
            # This should fail during vulnerability validation in __post_init__
            Vulnerability(
                uuid="",  # Invalid empty UUID
                title="Test Vulnerability",
                rule_name="test-rule",
                severity=VulnerabilitySeverity.MEDIUM
            )

        # Verify the error message is about the UUID
        self.assertIn("UUID is required", str(context_manager.exception))

    def test_create_with_components_success_with_logging(self):
        """Test that context creation logs the expected success message."""
        # Capture log output
        with self.assertLogs(level='INFO') as log_capture:
            context = RemediationContext.create_with_components(
                remediation_id="test-logging-id",
                vulnerability=self.valid_vulnerability,
                prompts=self.prompts,
                build_config=self.build_config,
                repo_config=self.repo_config
            )

        # Verify context was created successfully
        self.assertIsInstance(context, RemediationContext)
        self.assertEqual(context.remediation_id, "test-logging-id")

        # Verify the success log message was generated
        log_messages = [record.message for record in log_capture.records]
        success_message_found = any(
            "Created remediation context test-logging-id for vulnerability test-vuln-123" in msg
            for msg in log_messages
        )
        self.assertTrue(success_message_found, f"Expected success log message not found in: {log_messages}")


if __name__ == '__main__':
    unittest.main()
