#!/usr/bin/env python3
"""Unit tests for Vulnerability domain context classes."""

import unittest
from pathlib import Path
from unittest.mock import patch, MagicMock

# Test setup imports (path is set up by conftest.py)
from setup_test_env import create_temp_repo_dir, cleanup_temp_dir
from src.smartfix.domains.vulnerability.context import (
    RemediationContext, PromptConfiguration, BuildConfiguration, RepositoryConfiguration
)
from src.smartfix.domains.vulnerability.models import (
    Vulnerability, VulnerabilitySeverity
)


class TestPromptConfiguration(unittest.TestCase):
    """Test cases for PromptConfiguration value object."""

    def setUp(self):
        """Set up test environment."""
        pass

    def tearDown(self):
        """Clean up test environment."""
        pass

    def test_basic_creation(self):
        """Test basic PromptConfiguration creation."""
        prompts = PromptConfiguration(
            fix_system_prompt="Fix system prompt",
            fix_user_prompt="Fix user prompt",
            qa_system_prompt="QA system prompt",
            qa_user_prompt="QA user prompt"
        )

        self.assertEqual(prompts.fix_system_prompt, "Fix system prompt")
        self.assertEqual(prompts.fix_user_prompt, "Fix user prompt")
        self.assertEqual(prompts.qa_system_prompt, "QA system prompt")
        self.assertEqual(prompts.qa_user_prompt, "QA user prompt")

    def test_validation_required_fields(self):
        """Test validation of required prompt fields for SmartFix agents."""
        # Test missing fix_system_prompt for SmartFix
        with self.assertRaises(ValueError):
            prompts = PromptConfiguration(
                fix_system_prompt="",
                fix_user_prompt="Fix user prompt",
                qa_system_prompt="QA system prompt",
                qa_user_prompt="QA user prompt"
            )
            prompts.validate(require_all_prompts=True)

        # Test missing fix_user_prompt for SmartFix
        with self.assertRaises(ValueError):
            prompts = PromptConfiguration(
                fix_system_prompt="Fix system prompt",
                fix_user_prompt="",
                qa_system_prompt="QA system prompt",
                qa_user_prompt="QA user prompt"
            )
            prompts.validate(require_all_prompts=True)

    def test_external_agent_validation(self):
        """Test that external agents don't require prompts."""
        # External agents can have None prompts
        prompts = PromptConfiguration()  # All None by default
        prompts.validate(require_all_prompts=False)  # Should not raise

        # Test factory method for external agents
        external_prompts = PromptConfiguration.for_external_agent()
        external_prompts.validate(require_all_prompts=False)
        self.assertIsNone(external_prompts.fix_system_prompt)
        self.assertIsNone(external_prompts.qa_system_prompt)

    def test_smartfix_agent_factory(self):
        """Test SmartFix agent factory method."""
        prompts = PromptConfiguration.for_smartfix_agent(
            fix_system_prompt="Fix system prompt",
            fix_user_prompt="Fix user prompt",
            qa_system_prompt="QA system prompt",
            qa_user_prompt="QA user prompt"
        )

        self.assertEqual(prompts.fix_system_prompt, "Fix system prompt")
        self.assertEqual(prompts.qa_user_prompt, "QA user prompt")
        self.assertTrue(prompts.has_fix_prompts())
        self.assertTrue(prompts.has_qa_prompts())

    def test_prompt_availability_checks(self):
        """Test prompt availability check methods."""
        # Configuration with fix prompts only
        fix_only = PromptConfiguration(
            fix_system_prompt="Fix system",
            fix_user_prompt="Fix user"
        )
        self.assertTrue(fix_only.has_fix_prompts())
        self.assertFalse(fix_only.has_qa_prompts())

        # Configuration with no prompts
        no_prompts = PromptConfiguration()
        self.assertFalse(no_prompts.has_fix_prompts())
        self.assertFalse(no_prompts.has_qa_prompts())

    def test_optional_qa_prompts(self):
        """Test creation with optional prompts."""
        # Test that prompts can now be optional
        prompts = PromptConfiguration(
            fix_system_prompt="Fix system prompt",
            fix_user_prompt="Fix user prompt"
            # qa prompts are optional now
        )

        self.assertEqual(prompts.fix_system_prompt, "Fix system prompt")
        self.assertEqual(prompts.fix_user_prompt, "Fix user prompt")
        self.assertIsNone(prompts.qa_system_prompt)
        self.assertIsNone(prompts.qa_user_prompt)


class TestBuildConfiguration(unittest.TestCase):
    """Test cases for BuildConfiguration value object."""

    def test_basic_creation(self):
        """Test basic BuildConfiguration creation."""
        build_config = BuildConfiguration(
            build_command="npm test"
        )

        self.assertEqual(build_config.build_command, "npm test")
        self.assertIsNone(build_config.formatting_command)

    def test_full_creation(self):
        """Test BuildConfiguration creation with all fields."""
        build_config = BuildConfiguration(
            build_command="gradle test",
            formatting_command="gradle spotlessApply"
        )

        self.assertEqual(build_config.build_command, "gradle test")
        self.assertEqual(build_config.formatting_command, "gradle spotlessApply")

    def test_validation(self):
        """Test BuildConfiguration validation methods."""
        # Test with build command
        config = BuildConfiguration(build_command="test")
        self.assertTrue(config.has_build_command())

        # Test without build command
        config = BuildConfiguration()
        self.assertFalse(config.has_build_command())

        # Test with formatting command
        config = BuildConfiguration(formatting_command="format")
        self.assertTrue(config.has_formatting_command())

        # Test without formatting command
        config = BuildConfiguration()
        self.assertFalse(config.has_formatting_command())

    def test_formatting_command_handling(self):
        """Test formatting command handling."""
        # With formatting command
        config_with_formatting = BuildConfiguration(
            build_command="test",
            formatting_command="format"
        )
        self.assertEqual(config_with_formatting.formatting_command, "format")

        # Without formatting command
        config_without_formatting = BuildConfiguration(build_command="test")
        self.assertIsNone(config_without_formatting.formatting_command)


class TestRepositoryConfiguration(unittest.TestCase):
    """Test cases for RepositoryConfiguration value object."""

    def test_basic_creation(self):
        """Test basic RepositoryConfiguration creation."""
        repo_config = RepositoryConfiguration(
            repo_path=Path("/path/to/repo"),
            base_branch="main"
        )

        self.assertEqual(repo_config.repo_path, Path("/path/to/repo"))
        self.assertEqual(repo_config.base_branch, "main")
        self.assertIsNone(repo_config.working_branch)
        self.assertIsNone(repo_config.remote_url)

    def test_full_creation(self):
        """Test RepositoryConfiguration creation with all fields."""
        repo_config = RepositoryConfiguration(
            repo_path=Path("/app/code"),
            base_branch="main",
            working_branch="feature/vulnerability-fix",
            remote_url="https://github.com/company/project"
        )

        self.assertEqual(repo_config.repo_path, Path("/app/code"))
        self.assertEqual(repo_config.base_branch, "main")
        self.assertEqual(repo_config.working_branch, "feature/vulnerability-fix")
        self.assertEqual(repo_config.remote_url, "https://github.com/company/project")

    def test_validation(self):
        """Test RepositoryConfiguration validation."""
        # Test empty base_branch
        with self.assertRaises(ValueError):
            config = RepositoryConfiguration(
                repo_path=Path("/path"),
                base_branch=""
            )
            config.validate()

    def test_path_conversion(self):
        """Test that string paths are converted to Path objects."""
        repo_config = RepositoryConfiguration(
            repo_path="/string/path",
            base_branch="main"
        )

        self.assertIsInstance(repo_config.repo_path, Path)
        self.assertEqual(repo_config.repo_path, Path("/string/path"))


class TestRemediationContext(unittest.TestCase):
    """Test cases for RemediationContext aggregate root."""

    def setUp(self):
        """Set up test fixtures."""
        # Use helper for temp directory creation
        self.temp_dir = str(create_temp_repo_dir())

        # Create test vulnerability without location
        self.vulnerability = Vulnerability(
            uuid="vuln-123-456-789",
            title="Test Vulnerability",
            rule_name="test-rule",
            severity=VulnerabilitySeverity.HIGH
        )

        self.prompts = PromptConfiguration(
            fix_system_prompt="Fix system prompt",
            fix_user_prompt="Fix user prompt",
            qa_system_prompt="QA system prompt",
            qa_user_prompt="QA user prompt"
        )

        self.build_config = BuildConfiguration(
            build_command="pytest"
        )

        self.repo_config = RepositoryConfiguration(
            repo_path=Path(self.temp_dir),
            base_branch="main"
        )

    def tearDown(self):
        """Clean up test fixtures."""
        # Use helper for cleanup
        cleanup_temp_dir(Path(self.temp_dir))

    def test_basic_creation(self):
        """Test basic RemediationContext creation."""
        context = RemediationContext(
            remediation_id="test-remediation-123",
            vulnerability=self.vulnerability,
            prompts=self.prompts,
            build_config=self.build_config,
            repo_config=self.repo_config
        )

        self.assertEqual(context.remediation_id, "test-remediation-123")
        self.assertEqual(context.vulnerability, self.vulnerability)
        self.assertEqual(context.prompts, self.prompts)
        self.assertEqual(context.build_config, self.build_config)
        self.assertEqual(context.repo_config, self.repo_config)

    def test_external_agent_context(self):
        """Test RemediationContext creation for external agents."""
        # Create context with external agent configuration (no prompts)
        external_prompts = PromptConfiguration.for_external_agent()

        context = RemediationContext(
            remediation_id="external-agent-123",
            vulnerability=self.vulnerability,
            prompts=external_prompts,
            build_config=self.build_config,
            repo_config=self.repo_config
        )

        self.assertEqual(context.remediation_id, "external-agent-123")
        self.assertEqual(context.vulnerability, self.vulnerability)
        self.assertIsNone(context.prompts.fix_system_prompt)
        self.assertIsNone(context.prompts.qa_system_prompt)
        self.assertFalse(context.prompts.has_fix_prompts())
        self.assertFalse(context.prompts.has_qa_prompts())

    def test_validation(self):
        """Test RemediationContext validation."""
        # Our simplified dataclass doesn't do automatic validation
        # Test that we can create context with valid components
        context = RemediationContext(
            remediation_id="test-validation-123",
            vulnerability=self.vulnerability,
            prompts=self.prompts,
            build_config=self.build_config,
            repo_config=self.repo_config
        )

        # Test that context was created successfully
        self.assertIsNotNone(context.vulnerability)
        self.assertIsNotNone(context.prompts)
        self.assertIsNotNone(context.build_config)
        self.assertIsNotNone(context.repo_config)

    def test_workflow_state(self):
        """Test basic context state."""
        context = RemediationContext(
            remediation_id="test-workflow-123",
            vulnerability=self.vulnerability,
            prompts=self.prompts,
            build_config=self.build_config,
            repo_config=self.repo_config
        )

        # Test that context maintains its state
        self.assertEqual(context.remediation_id, "test-workflow-123")
        self.assertEqual(context.vulnerability.uuid, "vuln-123-456-789")

        # Test that context has all required components
        self.assertIsNotNone(context.prompts)
        self.assertIsNotNone(context.build_config)
        self.assertIsNotNone(context.repo_config)

    def test_create_factory_method(self):
        """Test create factory method."""
        # Mock a config object with the necessary attributes
        from unittest.mock import MagicMock
        mock_config = MagicMock()
        mock_config.REPO_ROOT = self.temp_dir
        mock_config.BASE_BRANCH = "main"
        mock_config.BUILD_COMMAND = "echo build"
        mock_config.FORMATTING_COMMAND = "echo format"

        context = RemediationContext.create(
            remediation_id="test-remediation-create",
            vulnerability=self.vulnerability,
            config=mock_config
        )

        self.assertIsInstance(context, RemediationContext)
        self.assertEqual(context.remediation_id, "test-remediation-create")
        self.assertEqual(context.vulnerability, self.vulnerability)
        self.assertEqual(str(context.repo_config.repo_path), self.temp_dir)
        self.assertEqual(context.repo_config.base_branch, "main")

    def test_can_run_qa(self):
        """Test basic context functionality."""
        # Context creation should work with valid QA prompts and build command
        context = RemediationContext(
            remediation_id="test-qa-123",
            vulnerability=self.vulnerability,
            prompts=self.prompts,
            build_config=self.build_config,
            repo_config=self.repo_config
        )

        # Test that context was created successfully
        self.assertIsInstance(context, RemediationContext)
        self.assertEqual(context.remediation_id, "test-qa-123")
        self.assertIsNotNone(context.prompts.qa_system_prompt)
        self.assertIsNotNone(context.build_config.build_command)

    def test_summary(self):
        """Test context summary generation."""
        context = RemediationContext(
            remediation_id="test-summary-123",
            vulnerability=self.vulnerability,
            prompts=self.prompts,
            build_config=self.build_config,
            repo_config=self.repo_config
        )

        # Test basic property access - simplified context has direct properties
        self.assertEqual(context.remediation_id, "test-summary-123")
        self.assertEqual(context.vulnerability.uuid, self.vulnerability.uuid)
        self.assertIsNotNone(context.prompts)
        self.assertIsNotNone(context.build_config)
        self.assertIsNotNone(context.repo_config)

    def test_string_representations(self):
        """Test string representations of context."""
        context = RemediationContext(
            remediation_id="test-repr-123",
            vulnerability=self.vulnerability,
            prompts=self.prompts,
            build_config=self.build_config,
            repo_config=self.repo_config
        )

        str_repr = str(context)
        repr_str = repr(context)

        # For dataclass, test that it contains the remediation_id and vulnerability UUID
        self.assertIn("test-repr-123", str_repr)
        self.assertIn(self.vulnerability.uuid, str_repr)
        self.assertIn("RemediationContext", repr_str)


class TestPromptProcessing(unittest.TestCase):
    """Test prompt processing functionality."""

    @patch("src.smartfix.domains.vulnerability.context.get_config")
    def test_get_processed_fix_user_prompt_with_security_test_skipped(self, mock_get_config):
        """Test that SecurityTest section is removed when SKIP_WRITING_SECURITY_TEST is True."""
        # Mock config with SKIP_WRITING_SECURITY_TEST=True
        mock_config = MagicMock()
        mock_config.SKIP_WRITING_SECURITY_TEST = True
        mock_get_config.return_value = mock_config

        original_prompt = ("Some text before\n"
                           "4. Where feasible, add a dedicated unit test for the security issue called "
                           "`SecurityTest.java` that specifically tests the security vulnerability fix:\n"
                           "   - This should specifically test the FIXED version of your code\n"
                           "   - **CRITICAL: When mocking")

        config = PromptConfiguration(
            fix_system_prompt="fix_sys",
            fix_user_prompt=original_prompt,
            qa_system_prompt="qa_sys",
            qa_user_prompt="qa_user"
        )

        processed = config.get_processed_fix_user_prompt()

        # Check that SecurityTest section is replaced
        self.assertNotIn("SecurityTest.java", processed)
        self.assertIn("4. Where feasible, add or update tests to verify the fix.", processed)
        self.assertIn("Use the 'Original HTTP Request' provided above", processed)

    @patch("src.smartfix.domains.vulnerability.context.get_config")
    def test_get_processed_fix_user_prompt_with_security_test_preserved(self, mock_get_config):
        """Test that SecurityTest section is preserved when SKIP_WRITING_SECURITY_TEST is False."""
        # Mock config with SKIP_WRITING_SECURITY_TEST=False
        mock_config = MagicMock()
        mock_config.SKIP_WRITING_SECURITY_TEST = False
        mock_get_config.return_value = mock_config

        original_prompt = ("Some text before\n"
                           "4. Where feasible, add a dedicated unit test for the security issue called "
                           "`SecurityTest.java` that specifically tests the security vulnerability fix:\n"
                           "   - This should specifically test the FIXED version of your code\n"
                           "   - **CRITICAL: When mocking")

        config = PromptConfiguration(
            fix_system_prompt="fix_sys",
            fix_user_prompt=original_prompt,
            qa_system_prompt="qa_sys",
            qa_user_prompt="qa_user"
        )

        processed = config.get_processed_fix_user_prompt()

        # Check that original prompt is unchanged
        self.assertEqual(processed, original_prompt)
        self.assertIn("SecurityTest.java", processed)

    def test_get_processed_fix_user_prompt_with_none_prompt(self):
        """Test that None is returned when fix_user_prompt is None."""
        config = PromptConfiguration(
            fix_system_prompt="fix_sys",
            fix_user_prompt=None,
            qa_system_prompt="qa_sys",
            qa_user_prompt="qa_user"
        )

        processed = config.get_processed_fix_user_prompt()
        self.assertIsNone(processed)

    @patch("src.smartfix.domains.vulnerability.context.get_config")
    def test_for_smartfix_agent_processes_fix_user_prompt(self, mock_get_config):
        """Test that for_smartfix_agent processes fix_user_prompt during creation."""
        # Mock config with SKIP_WRITING_SECURITY_TEST=True
        mock_config = MagicMock()
        mock_config.SKIP_WRITING_SECURITY_TEST = True
        mock_get_config.return_value = mock_config

        original_prompt = ("Some text before\n"
                           "4. Where feasible, add a dedicated unit test for the security issue called "
                           "`SecurityTest.java` that specifically tests the security vulnerability fix:\n"
                           "   - This should specifically test the FIXED version of your code\n"
                           "   - **CRITICAL: When mocking")

        config = PromptConfiguration.for_smartfix_agent(
            fix_system_prompt="fix_sys",
            fix_user_prompt=original_prompt,
            qa_system_prompt="qa_sys",
            qa_user_prompt="qa_user"
        )

        # Check that the fix_user_prompt has been processed
        self.assertNotIn("SecurityTest.java", config.fix_user_prompt)
        self.assertIn("4. Where feasible, add or update tests to verify the fix.", config.fix_user_prompt)

    def test_get_processed_qa_user_prompt_with_placeholders(self):
        """Test that QA user prompt placeholders are replaced correctly."""
        qa_prompt_template = ("Review the changes in {changed_files}. "
                              "Build output: {build_output}. "
                              "Previous attempts: {qa_history_section}")

        config = PromptConfiguration(
            fix_system_prompt="fix_sys",
            fix_user_prompt="fix_user",
            qa_system_prompt="qa_sys",
            qa_user_prompt=qa_prompt_template
        )

        changed_files = ["file1.py", "file2.py"]
        build_output = "Build failed with error"
        qa_history = "Attempt 1: Previous fix failed"

        processed = config.get_processed_qa_user_prompt(changed_files, build_output, qa_history)

        self.assertIn("file1.py, file2.py", processed)
        self.assertIn("Build failed with error", processed)
        self.assertIn("Attempt 1: Previous fix failed", processed)
        self.assertNotIn("{changed_files}", processed)
        self.assertNotIn("{build_output}", processed)
        self.assertNotIn("{qa_history_section}", processed)

    def test_get_processed_qa_user_prompt_with_none_prompt(self):
        """Test that None is returned when qa_user_prompt is None."""
        config = PromptConfiguration(
            fix_system_prompt="fix_sys",
            fix_user_prompt="fix_user",
            qa_system_prompt="qa_sys",
            qa_user_prompt=None
        )

        processed = config.get_processed_qa_user_prompt(["file1.py"], "build output", "history")
        self.assertIsNone(processed)


if __name__ == '__main__':
    unittest.main()
