#!/usr/bin/env python3
# -
# #%L
# Contrast AI SmartFix
# %%
# Copyright (C) 2025 Contrast Security, Inc.
# %%
# Contact: support@contrastsecurity.com
# License: Commercial
# NOTICE: This Software and the patented inventions embodied within may only be
# used as part of Contrast Security's commercial offerings. Even though it is
# made available through public repositories, use of this Software is subject to
# the applicable End User Licensing Agreement found at
# https://www.contrastsecurity.com/enduser-terms-0317a or as otherwise agreed
# between Contrast Security and the End User. The Software may not be reverse
# engineered, modified, repackaged, sold, redistributed or otherwise used in a
# way not consistent with the End User License Agreement.
# #L%
#

import unittest
import json
from unittest.mock import patch, MagicMock
import requests

from src import contrast_api


class TestContrastApiVulnerabilityDetails(unittest.TestCase):
    """Test cases for vulnerability details (not smartfix agent) in contrast_api module."""

    def setUp(self):
        """Set up test environment before each test."""
        self.sample_api_response = {
            'remediationId': 'e35d7cdc-a123-45f0-8099-0800db67j14a',
            "vulnerabilityUuid": "ABCD-D47P-FLTE-1234",
            "vulnerabilityTitle": "SQL Injection",
            "vulnerabilityRuleName": "sql-injection",
            "vulnerabilityStatus": "Reported",
            "vulnerabilitySeverity": "Critical",
            'vulnerabilityOverviewStory': 'vuln ... story',
            'vulnerabilityEventsSummary': 'vuln ... summary',
            'vulnerabilityHttpRequestDetails': 'vuln ... details',
        }

    def _call_get_vulnerability_details(self, **overrides):
        defaults = {
            "contrast_host": "test.contrastsecurity.com",
            "contrast_org_id": "test-org-id",
            "contrast_app_id": "test-app-id",
            "contrast_auth_key": "test-auth-key",
            "contrast_api_key": "test-api-key",
            "github_repo_url": "github.com/url/for/repo",
            "max_pull_requests": 10,
            "severities": []
        }
        return contrast_api.get_vulnerability_details(
            **{**defaults, **overrides})

    @patch('src.contrast_api.requests.post')
    def test_get_vulnerability_details_returns_valid_response_json(self,
        mock_post):
        """Test that successful API call returns JSON."""
        # Mock successful response
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.text = json.dumps(self.sample_api_response)
        mock_response.json.return_value = self.sample_api_response
        mock_post.return_value = mock_response

        response_json = self._call_get_vulnerability_details()

        # Focus on behavior: what does the user get back?
        self.assertEqual(response_json, self.sample_api_response)

    @patch('src.contrast_api.requests.post')
    def test_get_vulnerability_details_returns_none_when_no_vulnerabilities(
        self,
        mock_post):
        """Test that HTTP 204 result in None return value."""
        # Mock HTTP valid response, no vulns
        mock_response = MagicMock()
        mock_response.status_code = 204
        mock_post.return_value = mock_response

        response_json = self._call_get_vulnerability_details()

        # Focus on user experience: what happens when app has no vulns?
        self.assertIsNone(response_json)

    @patch('src.contrast_api.requests.post')
    def test_get_vulnerability_details_returns_none_when_exceeds_pr_limit(self,
        mock_post):
        """Test that HTTP errors (max PRs) result in None return value."""
        # Mock HTTP error response
        mock_response = MagicMock()
        mock_response.status_code = 409
        mock_response.text = "Max open pull requests reached for this application"
        mock_post.return_value = mock_response

        response_json = self._call_get_vulnerability_details()

        # Focus on user experience: what happens when max PRs are reached?
        self.assertIsNone(response_json)

    @patch('src.contrast_api.requests.post')
    def test_get_vulnerability_details_returns_none_when_bad_request(self,
        mock_post):
        """Test that HTTP errors result in None return value."""
        # Mock HTTP error response
        mock_response = MagicMock()
        mock_response.status_code = 400
        mock_response.text = "Bad request"
        mock_post.return_value = mock_response

        response_json = self._call_get_vulnerability_details()

        # Focus on user experience: what happens when bad request?
        self.assertIsNone(response_json)

    @patch('src.contrast_api.requests.post')
    def test_get_vulnerability_details_request_error(self, mock_post):
        """Test handling of request exceptions."""
        # Create a RequestException instance
        mock_post.side_effect = requests.exceptions.RequestException(
            "Connection error")

        response_json = self._call_get_vulnerability_details()

        self.assertIsNone(response_json)

    @patch('src.contrast_api.requests.post')
    def test_get_vulnerability_details_json_error(self, mock_post):
        """Test that malformed JSON results in None return value."""
        mock_response = MagicMock()
        mock_response.status_code = 200
        mock_response.json.side_effect = json.JSONDecodeError("Expecting value",
                                                              "doc", 0)
        mock_post.return_value = mock_response

        response_json = self._call_get_vulnerability_details()

        self.assertIsNone(response_json)


if __name__ == '__main__':
    unittest.main()
